{
  "home": {
    "reactWiki": "React Wiki",
    "warningBox": "<b>Esta Wiki esta pensada para gente que ya posee cierto conocimiento con React</b> pero que por diferentes motivos se han olvidado de algunas de sus funciones o necesita reforzarlas.",
    "introduction": "Introducción",
    "introductionDetails": "Aquí encontraremos varios ejemplos para saber utilizar las principales ventajas de React.<br><br>Ten presente que por motivos de incompatibilidad se han tenido que eliminar las llavecillas de los cuadros de codigos de ejemplos y no es completamente fiel a como realmente hay que escribirlo.<br><br>Si lo necesitas siempre puedes recurrir al código original en:<br><br>",
    "gitHub": "GitHub",
    "sandBox": "SandBox",
    "infoBoxTitle": "¿Que es React?",
    "infoBox": "La tecnología 'React', también conocida como 'React.js' o simplemente 'React', es una biblioteca de JavaScript desarrollada por Facebook. Se utiliza para construir interfaces de usuario interactivas y reutilizables en aplicaciones web. React se centra en la creación de componentes reutilizables que representan diferentes partes de la interfaz de usuario y su estado.<br><br>La principal característica de React es su enfoque en la construcción de interfaces de usuario mediante la utilización de componentes. Un componente en React es una unidad independiente que puede contener su propia lógica y estado, y puede renderizarse en la interfaz de usuario de acuerdo con las actualizaciones del estado. Esto permite la creación de interfaces de usuario modulares y escalables.<br><br>React utiliza un modelo de programación llamado 'Virtual DOM' (DOM Virtual), que es una representación en memoria de la estructura actual de la interfaz de usuario. Cuando el estado de un componente cambia, React genera una actualización virtual del DOM en lugar de manipular directamente el DOM del navegador. Luego, compara esta actualización virtual con la versión anterior para determinar los cambios reales que deben aplicarse al DOM real. Esta técnica de optimización ayuda a mejorar el rendimiento y la eficiencia de las aplicaciones.<br><br>React es muy popular en el desarrollo web moderno y se combina a menudo con otras bibliotecas y herramientas para construir aplicaciones completas. Para administrar el estado de las aplicaciones en React, se pueden usar soluciones como 'Redux' o 'Mobx'. Además, React puede integrarse con marcos de trabajo de desarrollo web como 'React Router' para manejar la navegación y 'Axios' para realizar solicitudes HTTP.<br><br>En resumen, React es una tecnología que permite construir interfaces de usuario interactivas y dinámicas en aplicaciones web a través de componentes reutilizables y un enfoque eficiente en la manipulación del DOM."
  },
  "hooks": {
    "useEffect": {
      "title": "useEffect",
      "infoBox": "Con el hook <b>useEffect</b> lo que le estamos indicando a React es que el componente <b>tiene que hacer algo después de renderizarse</b>.<br><b>El componente volverá a renderizarse si cambiamos su estado</b> y con ello volverá a ejecutar el useEffect.<br><b>Podemos evitar que ocurra esto añadiendole un array vacio</b> como segundo valor <b>o que se vuelva a ejecutar el useEffect solo si un estado en concreto cambia metiendolo en dicho array</b>.<br>Tambien podemos hacer <b>que ocurra algo una vez que el componente se desmota</b> para poder liberar memoria o cualquier otro tipo de función, esto lo haremos <b>retornando la propia funcion del useEffect.</b><br><br>En este ejemplo de validacion estamos haciedo uso del hook <b>useEffect</b> para hacer validaciones solo cuando cambia el estado de mail y de password (Estos cambian segun se escribe), pero para no comprobar la validacion mientras se esta escribiendo estamos aplicando un setTimeout y limpiandolo cada vez que se vuelve a escribir (Gracias al retorno del hook)<br><br>Esto es solo un ejemplo para ver el funcionamiento del useEffect pero para un caso así sería mas optimo de hacer uso del hook"
    },
    "useMemoAndUseCallback": {
      "title": "useMemo y useCallback",
      "infoBox": "Cuando tenemos componentes muy pesados y estos se renderizan innecesariamente puede afectar al rendimiento de nuestra aplización.<br><br>Para no reenderizar el elemento hijo si se vuelve a renderizar el padre usamos la funcion <b>React.memo(elemento)</b>.<br><b>El elemento solo se renderizará al cambiar sus props</b>.<br><br>Además a este componente le estamos pasando desde el padre el array numbers mediante la prop exampleArray usando el hook <b>useMemo</b>.<br>Tambien le pasamos la función cambiarNombrePadre, para cambiar el estado del padre desde el hijo usando el hook <b>useCallback</b>.<br><br>Se han de usar estos hooks porque hay que tener en cuenta que tanto si pasamos <b>props de array, de objetos o de metodos</b>, estos <b>no son valores primitivos de JavaScript</b>, y este <b>se piensa que son diferentes</b> aunque realmente no hayan cambiado y por eso debemos memorizarlos con estos hooks.<br><br>Gracias a la extensión <b>react developers tools</b> y marcando en su configuración '<b>Highlight updates when components render</b>' podemos comprobar los componentes que se renderizan segun interactuamos con ellos.<br>Puedes ayudarte tambien viendo los logs de la consola."
    },
    "useReducer": {
      "title": "useReducer",
      "infoBox1st": "Con el hook <b>useReducer</b> tenemos un uso del estado vitaminado para ejecuciones mas complejas.<br>Podemos echar un vistazo a este esquema para poder comprender su funcionamiento:<br>",
      "infoBox2nd": "<br>En este caso estamos validando el mail y la password por useReducer y hacemos uso del useEffect para habilitar o deshabilitar el boton solo en caso de que cambie el estado de la validación, inspecciona el código del proyecto para ver su funcionamiento."
    }
  },
  "libraries": {
    "redux": {
      "reduxBasic": {
        "title": "Redux Básico",
        "warningBox": "Para poder usar este componente es necesario <b>utilizar la store básica</b>, cambiando en <b>src/index.js</b> la linea 16 <b>storeReduxToolkit por storeReduxbasic</b>.",
        "infoBox1st": "<p>Cada componente puede tener su propio estado que cambia con el tiempo, por ejemplo, el número de 'Me gusta' en una publicación o la información del usuario.<br><br>Sin embargo, cuando tu aplicación crece, <b>mantener un seguimiento de todos estos estados puede volverse complicado</b>. Aquí es donde <b>Redux</b> entra en juego para ayudarte:</p><ul><li><b>Almacén (Store)</b>: Piensa en el almacén de Redux como un gran contenedor para todos los estados importantes de tu aplicación. Es como un lugar central donde guardas información relevante, como la información del usuario, las publicaciones, etc.</li><li><b>Acciones (Actions)</b>: Las acciones en Redux son como solicitudes para cambiar algo en tu almacén. Por ejemplo, si alguien hace clic en un botón 'Me gusta', eso genera una 'acción' para aumentar el contador de 'Me gusta'. Las acciones son pequeños objetos que describen qué sucedió.</li><li><b>Reductores (Reducers)</b>: Los reductores son como las personas encargadas de procesar esas acciones y hacer cambios en el almacén. Toman la acción y actualizan el estado en función de lo que debería cambiar. Por ejemplo, un reductor tomará la acción de 'Aumentar Me gusta' y ajustará el número de Me gusta en el estado del almacén. </li><li><b>Despachar (Dispatch)</b>: Es como decirle a Redux que ocurrió algo y que debe manejarlo. Por ejemplo, cuando alguien hace clic en un botón, puedes 'despachar' una acción, que luego será manejada por los reductores para actualizar el estado en el almacén. </li><li><b>Suscribirse (Subscribe)</b>: Puedes 'suscribir' componentes específicos al almacén de Redux. Esto significa que esos componentes serán notificados cada vez que el estado en el almacén cambie. De esta manera, puedes actualizar automáticamente la interfaz de usuario para que coincida con el estado actual. </li></ul><p>En resumen, Redux trabaja en conjunto con React para ayudarte a manejar el estado de tu aplicación de una manera más organizada y predecible. Te brinda una estructura clara para gestionar cambios en el estado, lo que es especialmente útil cuando tu aplicación se vuelve más grande y compleja.<br><br>Para poder utilizarlo debemos:</p><ul><li><b>Instalarnos</b> los paquetes npm <b>redux y react-redux</b></li><li><b>Importar el Provider</b> Redux y <b>envolver los componentes</b>.</li><li><b>Crear nuestra Store y pasarla como atributo en el componente Provider</b></li><li><b>Usar useSelector, useDispatch</b> de react-redux en los componentes donde queramos cambiar el estado de Redux</li></ul><p>Como nota importante saber que nuestros Reducers siempre deben retornar el objeto entero de nuevo, esto puede llevar a que nuestro archivo sea demasiado grande y dificil de mantener es por eso que para facilitarnos la tarea ahora tenemos a nuestra dispoción</p>",
        "infoBox2nd": "Como nota importante saber que nuestros Reducers siempre deben retornar el objeto entero de nuevo, esto puede llevar a que nuestro archivo sea demasiado grande y dificil de mantener es por eso que para facilitarnos la tarea ahora tenemos a nuestra dispoción"
      },
      "reduxToolkit": {
        "title": "Redux Toolkit",
        "warningBox": "Si el componente no funciona recuerda que para poder usar este componente es necesario <b>utilizar la store toolkit</b>, cambiando en <b>src/index.js</b> la linea 16 <b>storeReduxbasic por storeReduxToolkit</b>.",
        "infoBox": "<p>Redux Toolkit es un conjunto de herramientas y utilidades diseñadas para hacer que el proceso de desarrollo con Redux sea más eficiente, más sencillo y menos propenso a errores. Fue creado por el mismo equipo que desarrolló Redux y está destinado a simplificar muchas de las tareas comunes que se realizan al configurar y administrar una tienda de Redux.<br><br>Redux Toolkit ofrece varias características y beneficios que facilitan el desarrollo de aplicaciones utilizando Redux:</p><ul><li><b>Configuración simplificada:</b> Redux Toolkit proporciona una función llamada configureStore() que simplifica la configuración inicial de tu almacén (store) Redux. Esta función incorpora configuraciones y características recomendadas, como la inmutabilidad automática y el manejo de devolución de llamadas de thunk (para acciones asíncronas).</li><li><b>Acciones y reductores simplificados:</b> Redux Toolkit ofrece una función createSlice() que combina la definición de acciones y reductores en una única función. Esto elimina gran parte de la repetición de código que suele ocurrir al definir acciones y reductores por separado.</li><li><b>Manejo automático de la inmutabilidad:</b> Redux Toolkit utiliza la biblioteca 'Immer' para simplificar la creación de nuevos estados inmutables. Esto significa que puedes modificar el estado como si fuera mutable, y Redux Toolkit se encargará de crear una copia inmutable automáticamente.</li><li><b>Integración de DevTools:</b> Redux DevTools es una herramienta muy útil para depurar y rastrear el estado y las acciones en tu aplicación. Redux Toolkit incluye la configuración de DevTools de manera predeterminada, lo que facilita su integración y uso.</li><li><b>Mejor soporte para acciones asíncronas:</b> Redux Toolkit incluye la capacidad de manejar acciones asíncronas más fácilmente mediante el middleware 'Redux Thunk' y otros enfoques, lo que facilita la realización de operaciones asincrónicas como llamadas a API.</li></ul>"
      }
    },
    "routerDom": {
      "dynamicRoutes": {
        "title": "Rutas Dinámicas",
        "infoBox": "Estamos aprovechando este ejemplo para añadir un buscador y navegar atraves del boton a la imagen indicada en el fomulario, a su vez tambien se añaden <strong>URLs dinámicas</strong> en el <strong>App.js</strong><br><br>Como se puede apreciar en el código la parte dinamica será indicada por dos puntos mas el nombre que queramos ponerle en la parte dinámica."
      },
      "dynamicRoutesDetail": {
        "title": "Detalle imagen",
        "infoBox": "Podemos ver como le hemos pasado la propiedad por contexto y no hemos vuelto a hacer una llamada para la carga de la imagen.<br/><br/>Hemos utilizado tambien el <strong>useParams</strong> de react-router-dom, para que mediante el parametro dinamico de la URL mostremos la imagen que nos interesa del listado que habiamos cargado previamente.",
        "returnPage": "Volver a la página anterior",
        "imageDetail": "Detalle de la imagen",
        "imageNoFound": "Imagen no encontrada, por favor busque un id de imagen existente."
      },
      "simpleRoutes": {
        "title": "Enlaces Simples",
        "infoBox": "Usamos el paquete npm <strong>react-router-dom</strong> para poder utilizar las ventajas del single page application.<br><br> Se deberán importar los componentes necesarios <strong>Link, Routes y Route</strong>, siendo <strong>Routes</strong> el area donde se irán renderizando los componentes según su URL",
        "linkExample": "Enlace de ejemplo"
      }
    }
  },
  "others": {
    "apis": {
      "title": "APIs",
      "infoBox": "Usamos las funciones asincronas <b>async</b> de JavaScript para hacer peticiones a APIs, haremos las peticiones con funciones <b>fetch</b> añadiendole el <b>await</b> delante- <br>Para posibles estados como los errores debemos envolver con <b>try</b> todo el código de los datos y con <b>catch</b> podremos encontrar las diferentes respuestas de la petición.<br><br>Este tipo de código es propio de JavaScript para una información mas concreta puede consultar en mdn web docs los &nbsp;<a href='https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Statements/async_function' target='_blank' rel='noreferrer'>async functions</a> y los &nbsp;<a href='https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Statements/try...catch' target='_blank' rel='noreferrer'>try...catch</a>.<br><br>Este ejempo se ha llevado a cabo con <a href='https://console.firebase.google.com/' target='_blank' rel='noreferrer'>Firebase</a> y es posible que deje de funcionar en un futuro próximo.<br>Si es necesario tenga en presente crear una cuenta en dicha página y cambiar la variable del componente <b>URLAPI</b>"
    },
    "contexts": {
      "title": "Contextos",
      "infoBox": "Con el <strong>Context provider</strong> puedo tener valores guardados y cambiar su estado entre multiples componentes sin tener que pasarles propiedades. Parecido al famoso Redux.<br><br>En este ejemplo estamos usando el context provider comnbinado con el useState para guardar la informacion de las imagenes, así al irnos a su detalle no volveremos hacer una llamada a la API para renderizarlas ya que tendremos ya guardado un contexto global para consultarlo.<br><br>Como se puede apreciar en el código el contexto tiene que envolver todos los componentes donde se quiera leer"
    },
    "moduleCSS": {
      "title": "ModuleCSS",
      "infoBox": "Gracias a los <b>estilos CSS modulares</b> podemos hacer que los estilos se apliquen a un solo componente <b>evitando una indeseada propagación</b>.<br><br>Para ello <b>es necesario que el archivo CSS acabe en .module.css</b> en este ejemplo usamos 'LoginUseEffect.module.css' Le ponemos nombre a la variable que lo importa y la usamos en nuestro HTML.<br><br>Inspecciona el código del proyecto para ver como se aplican los estilos modulares."
    },
    "lazyComponent": {
      "title": "Lazy Component",
      "infoBox": "Si abrimos la consola del navegador podremos comprobar que no nos aparecerá el mensage del componente '<b>carga del lazy component</b>', hasta que llegue el scroll a mostralo, esto es gracias a la clase <b>IntersectionObserver</b>.<br><br>Estamos observando la caja que envuelve al componente usando una referecia de React gracias a su metodo <b>useRef()</b>.<br><br>Por rendimiento siempre nos deberemos desconectar de la observación con el metodo <b>disconnect()</b> cuando ya no tengamos que usarla.<br><br>Por otro lado tambien en la consola podemos ver como se va actualizando las propiedades del objeto con un monton de información que podremos utilizar segun a nuestras necesidades.",
      "ScrollDownToLoad": "Haz scroll hasta llegar al componente para cargarlo!"
    }
  }
}